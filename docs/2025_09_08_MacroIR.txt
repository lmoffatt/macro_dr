_Bueno, vamos a ver, cuento un poco en qué estoy con macro IR. Bueno, yo tengo corriendo algunos modelos ya, entonces ahora me puedo dedicar a volver a tener un macro IR que corra con nuevas sintaxis. o sea, un poco una sintaxis que me guste más y la cual pueda implementar las ideas de HOT de Homo-Topy Type Theory en la ¿cómo llaman? Command Line Interface de manera que bueno, qué sé yo que pueda estudiar esas ideas y ver a qué conducen y expresar, digamos, algunas ideas que me parecen lindas en código y sentirme contento con eso. Pero bueno, hay una diferencia. Una cosa es el placer de programar cosas lindas, otra cosa es el deber profesional de publicar y que me paguen un sueldo por eso. Esa tensión entre esas dos cosas. También la idea es que yo programo lindo y con eso que sea un programa que sea mejor, que cumpla mejor esas funciones que yo digo, de ser más entendible, que otros lo puedan usar fundamentalmente, y que otros lo puedan usar, y que corran más que nada, más que que otros lo puedan usar, otros lo van a poder usar en tal medida que sea eficiente para hacer las tareas para las cuales lo queremos usar. Entonces lo primero que habría que definir es qué es lo que quiero usar, y bueno, lo que quiero hacer es usarlo para poder sacar información cinética de corrientes, de macrocorrientes y también de set de resultados experimentales. O sea, que yo tenga, o sea, eso son dos cosas, una es macro IR y otra cosa es Luthier, ¿no? O sea, macro IR lo que se especializaría en obtener, en hacer modelos cinéticos y bueno, y tratar de modelos cinéticos los cuales, digamos, un macro IR tiene que ser el algoritmo macro IR que permite obtener información cinética de fluctuaciones de macrocorrientes, los cuales son de canales iónicos, pero podrían ser también de motores moleculares. Bueno, eso es todo una pregunta, ¿no? Si me voy a meter en motores moleculares y todo. Pero bueno, van viendo poco para atrás. En principio tengo que poder sacar eficientemente de macrocorrientes informaci cin de una manera que sea robusta y confiable y que al mismo tiempo digamos nos ilumine en aspectos del mecanismo de activación de los canales no se es un poco el objetivo sólo logré con creces en el paper que estamos publicando en comunica y ahí lo logro bien, pero bueno, el tema es que las corridas son muy largas, o sea que el tema aquí es fundamental, sería que las corridas sean un poco más rápidas, eso me parece que es lo más importante, y yo me estoy distrayendo mucho en el tema de la belleza o comprensión del programa, Pero eso tiene que ver porque el programa ya tenía una complejidad que era difícil de manejar, entonces un poco lo tengo que domar y poder llevar a algo que sea interpretable, comprensible para otros y que pueda ser refactorizado más o menos rápido. O sea, la idea es que modularizar un poco el programa de manera que se pueda, digamos, razonar acerca de él de una manera más o menos fácil, ¿no? Porque ahora es un poco complejo. No me cabe a mí, ni a mí en la cabeza. Tiene un montón de secciones del programa, bueno, que son zombies y, bueno, tengo que eliminar los zombies. O sea, para poder eliminar los zombies y tener un programa mínimo que pueda realizar las tareas que tiene que realizar, bueno, para eso lo primero que tengo que hacer es definir test que me permitan decir, bueno, este programa que yo lo cambié, le saqué esta parte que me parece que estaba al pedo, sigue funcionando. y además un test que me diga qué tan rápido funciona, es decir, que tenga una idea de la eficiencia. O sea, que yo pueda medir del programa si cumple sus objetivos y con qué eficiencia. Eso es un poco el objetivo que tengo ahora a corto plazo, es decir, lograr que MacroIR me dé, yo pueda decir, bueno, yo corro, tengo esta versión de MacroIR, bueno, le corro estos test y me dice, bueno, funciona como venía funcionando y qué velocidad tiene. Entonces ahí yo ya puedo empezar a optimizarlo. O sea, ese es el objetivo. El objetivo tiene que ser exactamente ese. Lograr ahora, digamos, hacerlo funcionar de..._
_vuelta, porque en este momento no funciona, y tener separado una parte que es la l de la command line interface que ya tiene que ser digamos una tengo que tener un un domain specific language con ciertas funciones m y variables y todo ya definidas y más o menos rígidas y que permanentes tengo que tener eso y tengo que tener una mínima implementación con clases virtuales que después yo las clases concretas pueda variar de manera de que se optimicen o sea que sea llegar a una interfaz que sea más o menos estable y luego poder trabajar en la parte de implementación y buscar una implementación que vaya mejorando o sea que yo pueda mejorar y mantener la interfaz estable y tener una implementación que vaya siendo optimizada. Ese sería, es exactamente mi objetivo y donde la interfaz, y tengo que tener, digamos, más o menos separado las distintas responsabilidades con namespaces y directorios adecuados. Tengo, por ejemplo, la parte de los comandos. O sea, tengo varias cosas. Bueno, primero tengo que tener un lenguaje para armar los comandos. Y, digamos, tengo un propio lenguaje interno que me permita definir comandos, definir, digamos, sería como un lenguaje de programación de la Domain Specific Language. o sea, es una especie de metalinguaje. Después yo tengo el Domain Specific Language explicado a Macro IR, y ese Domain Specific Language va a tener una serie de clases, que serían clases virtuales, como el e-model, el e-experiment, y algoritmo, todas esas cosas, que después yo puedo ir agregando nuevas clases dentro de eso. En principio esas clases serían ya rígidas, es decir, para hacer una nueva tendría que recompilar todo, pero luego puedo llegar a pensar en una forma de construir yo, o sea, de un lenguaje que me permita construir nuevas funciones, etc. o sea que sea digamos m din Bueno esa ser como una segunda etapa La primera etapa es lo que tengo ya digamos que est dentro de este criterio de tener separados los dos o tres universos que serían, bueno, por un lado el universo de la implementación del Domain Specific Language, por otro lado el Domain Specific Language de Macro y R con los comandos específicos y las clases específicas, etc. Y después, bueno, ya sea la implementación de eso. Que esa implementación podría cambiar y podría ser que yo pueda, es más, seleccionar distintas implementaciones dentro de la parte más externa del programa, la superior, puedo elegir qué implementación uso, la implementación 1, 2, 3, 4, elegirla dinámicamente. Es más, tiene que ser así porque entonces ahí puedo, a ese nivel superior, comparar los distintos algoritmos. Yo tengo tres varios algoritmos, entonces tengo que poder, digamos, testearlos, o sea, medirlos con casos claros a nivel superior, a nivel de la ventana superior, cosa de tener un registro, digamos, comparable y registrable, documentable, de cómo uno va evolucionando la implementación. Es decir, que luego, digamos, siendo esa parte externa del programa más o menos estable, lo que va evolucionando es la parte interna. Esa es un poco la idea y que esa evolución sea toda documentada y bueno, cada tanto yo voy publicando la evolución de eso, ese es mi plan maestro de trabajo y es el que tengo que seguir, ¿no es cierto? Entonces ahora lo que estaba un poco preocupado era exactamente cómo integraba la parte de abajo del programa con la parte media, porque tendría una parte superior, que es la parte totalmente abstracta, la parte media, que son las cosas concretas, pero que pueden tener distintas implementaciones posibles y después la parte de implementación. Yo no sé si llamarlo, digamos, core and implementation. Como distintas, que podrían ser las implementations, podrían ser directamente cada una con un namespace separado, posiblemente._
 -- Transcrito por zapia.com, tu IA personal
 _otra cosa que estaba pensando en términos de facilities que yo voy a tener una facility por ejemplo para testing, o sea para definir los preconditions y postconditions y ver que eso se cumpla como hacer un domain specific language que permita expresar eso eso es una facility si querés otra facility que sea para salvar Otra facility es el environment Es como guardar variables Y recuperarlas Otra facility es como guardar el environment En el disco rígido y como cargarlo Otra facility puede ser como correr Programas en un cluster Otra facility puede ser Como elegir entre distintas implementaciones de un mismo algoritmo, una misma clase. Todas esas cosas están un poco interconectadas y claro uno puede tener una especie de mayordomo que elija digamos que optimice todas esas decisiones que vos digas bueno yo voy y tengo distintas implementaciones mido la eficiencia en términos de tiempos y lo que sea, y los recursos que tengo, entonces elijo lo que me conviene para determinadas circunstancias. esta sería como una facilidad de optimización también después tengo facilidades que tienen que ver ya más específicas en cuanto a bueno, modelo cinético facilidades que tienen que ver con experimentos otra que tiene que ver con distintos tipos de algoritmos y específicos algoritmos en general como digamos setear los parámetros de algoritmos y después bueno algoritmos específicos, algoritmos de simulación algoritmos de sampleado de evidencia de digamos de macro rs de macroscopic recursive likelihood serían un poco las distintas este facilitis o no sé cómo llamarlo que tiene macro de respuesta con que ver si alguna más que me falta_
 -- Transcrito por zapia.com, tu IA personal
