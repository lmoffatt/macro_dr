Based on the parsing and grammar logic implemented in `grammar_untyped.h` and `lexer_untyped.h`, here is a faithful draft of `dsl/grammar.bnf` that matches the actual supported syntax in MacroIR today:

---

```bnf
# MacroIR DSL Grammar Specification (BNF)
# Status: DRAFT
# Last Updated: 2025-07-17

<program>         ::= <statement>*                       # Multiple statements per program

<statement>       ::= <assignment>
                   | <function_call>
                   | <identifier>
                   | <literal>
                   | <string_literal>
                   | <argument_list>

<assignment>      ::= <identifier> "=" <expression>      # a = f(...)

<function_call>   ::= <identifier> "(" <argument_list>? ")"  # simulate(...)

<argument_list>   ::= <argument> ("," <argument>)*       # supports keyword args

<argument>        ::= <assignment>
                   | <expression>

<expression>      ::= <literal>
                   | <string_literal>
                   | <identifier>
                   | <function_call>
                   | <argument_list>

<literal>         ::= <number>
<number>          ::= [0-9]+ ("." [0-9]+)?                # supports floats

<string_literal>  ::= "\"" .*? "\""                      # quoted string

<identifier>      ::= [a-zA-Z_][a-zA-Z0-9_]*              # function names, variable names
```

---

### ðŸ§  Observed Implementation Constraints

* Argument lists can contain both positional expressions and keyword assignments.
* Nested expressions are supported (e.g., `simulate(model=init("lin"))`).
* Literals include numeric and string types; identifiers and function calls are contextually resolved.
* No control flow, blocks, or multi-line structures yet.
* Comments (`# ...`) are parsed but ignored.

---

Would you like this BNF version embedded with comments for each rule and a `.str()` rendering example per case?

